Return-Path: <linux-arm-kernel-bounces+lists+linux-arm-kernel=lfdr.de@lists.infradead.org>
X-Original-To: lists+linux-arm-kernel@lfdr.de
Delivered-To: lists+linux-arm-kernel@lfdr.de
Received: from bombadil.infradead.org (bombadil.infradead.org [IPv6:2607:7c80:54:e::133])
	by mail.lfdr.de (Postfix) with ESMTPS id 3B2BF8D5D2
	for <lists+linux-arm-kernel@lfdr.de>; Wed, 14 Aug 2019 16:20:15 +0200 (CEST)
DKIM-Signature: v=1; a=rsa-sha256; q=dns/txt; c=relaxed/relaxed;
	d=lists.infradead.org; s=bombadil.20170209; h=Sender:
	Content-Transfer-Encoding:Content-Type:Cc:List-Subscribe:List-Help:List-Post:
	List-Archive:List-Unsubscribe:List-Id:MIME-Version:References:In-Reply-To:
	Subject:To:From:Message-ID:Date:Reply-To:Content-ID:Content-Description:
	Resent-Date:Resent-From:Resent-Sender:Resent-To:Resent-Cc:Resent-Message-ID:
	List-Owner; bh=SF+DBYp9kC198A1fkXrgpAncwrToH03MUGGZGjBthAY=; b=e7po/OtRUD4BiQ
	79ytN1vJ3h17lqC0uZMwZSF6x1RmJrUIyyFSNJgm6vemOD6U1YSieB8UZWkSGwld2rcS46m1WOEY5
	0udRTh5fLXfssUTGIGsn0WSwXJuIx0l0PufYQ2zTBNyAQEdj431m+boP3V/EVFCnxfiojOYGAfgOV
	BpjFEi3WlUXxzvOUkDqfsvl/vYH7tL32U0UF+3BPqX2E7j+GvE2jYhiJkNC9jCrLeDKvAedGdNbl3
	Lm4zKALWStnJWRe8TUziu/F93TZUHuzFarf5Whxgg8jTG00FgHnD4zweo+N0qXmAMokhYzDPDEZsk
	GNHBhbGjYQXpgvvNscZQ==;
Received: from localhost ([127.0.0.1] helo=bombadil.infradead.org)
	by bombadil.infradead.org with esmtp (Exim 4.92 #3 (Red Hat Linux))
	id 1hxu8D-0006Jy-MX; Wed, 14 Aug 2019 14:20:05 +0000
Received: from foss.arm.com ([217.140.110.172])
 by bombadil.infradead.org with esmtp (Exim 4.92 #3 (Red Hat Linux))
 id 1hxu7w-0006Jc-Go
 for linux-arm-kernel@lists.infradead.org; Wed, 14 Aug 2019 14:19:50 +0000
Received: from usa-sjc-imap-foss1.foss.arm.com (unknown [10.121.207.14])
 by usa-sjc-mx-foss1.foss.arm.com (Postfix) with ESMTP id 9965828;
 Wed, 14 Aug 2019 07:19:46 -0700 (PDT)
Received: from big-swifty.misterjones.org (unknown [172.31.20.19])
 by usa-sjc-imap-foss1.foss.arm.com (Postfix) with ESMTPSA id BBF673F694;
 Wed, 14 Aug 2019 07:19:41 -0700 (PDT)
Date: Wed, 14 Aug 2019 15:19:02 +0100
Message-ID: <8636i3omnd.wl-maz@kernel.org>
From: Marc Zyngier <maz@kernel.org>
To: Alexander Graf <graf@amazon.com>
Subject: Re: [PATCH 0/9] arm64: Stolen time support
In-Reply-To: <8ca5c106-7c12-4c6e-6d81-a90f281a9894@amazon.com>
References: <20190802145017.42543-1-steven.price@arm.com>
 <20190803190522.5fec8f7d@why>
 <6789f477-8ab5-cc54-1ad2-8627917b07c9@arm.com>
 <8ca5c106-7c12-4c6e-6d81-a90f281a9894@amazon.com>
User-Agent: Wanderlust/2.15.9 (Almost Unreal) SEMI-EPG/1.14.7 (Harue)
 FLIM/1.14.9 (=?UTF-8?B?R29qxY0=?=) APEL/10.8 EasyPG/1.0.0 Emacs/26
 (aarch64-unknown-linux-gnu) MULE/6.0 (HANACHIRUSATO)
Organization: Approximate
MIME-Version: 1.0 (generated by SEMI-EPG 1.14.7 - "Harue")
X-CRM114-Version: 20100106-BlameMichelson ( TRE 0.8.0 (BSD) ) MR-646709E3 
X-CRM114-CacheID: sfid-20190814_071948_650861_8565B8B9 
X-CRM114-Status: GOOD (  37.85  )
X-Spam-Score: 1.0 (+)
X-Spam-Report: SpamAssassin version 3.4.2 on bombadil.infradead.org summary:
 Content analysis details:   (1.0 points)
 pts rule name              description
 ---- ---------------------- --------------------------------------------------
 0.0 SPF_HELO_NONE          SPF: HELO does not publish an SPF Record
 1.0 SPF_SOFTFAIL           SPF: sender does not match SPF record (softfail)
X-BeenThere: linux-arm-kernel@lists.infradead.org
X-Mailman-Version: 2.1.29
Precedence: list
List-Id: <linux-arm-kernel.lists.infradead.org>
List-Unsubscribe: <http://lists.infradead.org/mailman/options/linux-arm-kernel>, 
 <mailto:linux-arm-kernel-request@lists.infradead.org?subject=unsubscribe>
List-Archive: <http://lists.infradead.org/pipermail/linux-arm-kernel/>
List-Post: <mailto:linux-arm-kernel@lists.infradead.org>
List-Help: <mailto:linux-arm-kernel-request@lists.infradead.org?subject=help>
List-Subscribe: <http://lists.infradead.org/mailman/listinfo/linux-arm-kernel>, 
 <mailto:linux-arm-kernel-request@lists.infradead.org?subject=subscribe>
Cc: kvm@vger.kernel.org, linux-doc@vger.kernel.org,
 Catalin Marinas <catalin.marinas@arm.com>, linux-kernel@vger.kernel.org,
 Russell King <linux@armlinux.org.uk>, Paolo Bonzini <pbonzini@redhat.com>,
 Steven Price <steven.price@arm.com>, Will
 Deacon <will@kernel.org>, kvmarm@lists.cs.columbia.edu,
 linux-arm-kernel@lists.infradead.org
Content-Type: text/plain; charset="us-ascii"
Content-Transfer-Encoding: 7bit
Sender: "linux-arm-kernel" <linux-arm-kernel-bounces@lists.infradead.org>
Errors-To: linux-arm-kernel-bounces+lists+linux-arm-kernel=lfdr.de@lists.infradead.org

On Wed, 14 Aug 2019 14:02:25 +0100,
Alexander Graf <graf@amazon.com> wrote:
> 
> 
> 
> On 05.08.19 15:06, Steven Price wrote:
> > On 03/08/2019 19:05, Marc Zyngier wrote:
> >> On Fri,  2 Aug 2019 15:50:08 +0100
> >> Steven Price <steven.price@arm.com> wrote:
> >> 
> >> Hi Steven,
> >> 
> >>> This series add support for paravirtualized time for arm64 guests and
> >>> KVM hosts following the specification in Arm's document DEN 0057A:
> >>> 
> >>> https://developer.arm.com/docs/den0057/a
> >>> 
> >>> It implements support for stolen time, allowing the guest to
> >>> identify time when it is forcibly not executing.
> >>> 
> >>> It doesn't implement support for Live Physical Time (LPT) as there are
> >>> some concerns about the overheads and approach in the above
> >>> specification, and I expect an updated version of the specification to
> >>> be released soon with just the stolen time parts.
> >> 
> >> Thanks for posting this.
> >> 
> >> My current concern with this series is around the fact that we allocate
> >> memory from the kernel on behalf of the guest. It is the first example
> >> of such thing in the ARM port, and I can't really say I'm fond of it.
> >> 
> >> x86 seems to get away with it by having the memory allocated from
> >> userspace, why I tend to like more. Yes, put_user is more
> >> expensive than a straight store, but this isn't done too often either.
> >> 
> >> What is the rational for your current approach?
> > 
> > As I see it there are 3 approaches that can be taken here:
> > 
> > 1. Hypervisor allocates memory and adds it to the virtual machine. This
> > means that everything to do with the 'device' is encapsulated behind the
> > KVM_CREATE_DEVICE / KVM_[GS]ET_DEVICE_ATTR ioctls. But since we want the
> > stolen time structure to be fast it cannot be a trapping region and has
> > to be backed by real memory - in this case allocated by the host kernel.
> > 
> > 2. Host user space allocates memory. Similar to above, but this time
> > user space needs to manage the memory region as well as the usual
> > KVM_CREATE_DEVICE dance. I've no objection to this, but it means
> > kvmtool/QEMU needs to be much more aware of what is going on (e.g. how
> > to size the memory region).
> 
> You ideally want to get the host overhead for a VM to as little as you
> can. I'm not terribly fond of the idea of reserving a full page just
> because we're too afraid of having the guest donate memory.

Well, reduce the amount of memory you give to the guest by one page,
and allocate that page to the stolen time device. Problem solved!

Seriously, if you're worried about the allocation of a single page,
you should first look at how many holes we have in the vcpu structure,
for example (even better, with the 8.4 NV patches applied). Just
fixing that would give you that page back *per vcpu*.

> > 3. Guest kernel "donates" the memory to the hypervisor for the
> > structure. As far as I'm aware this is what x86 does. The problems I see
> > this approach are:
> > 
> >   a) kexec becomes much more tricky - there needs to be a disabling
> > mechanism for the guest to stop the hypervisor scribbling on memory
> > before starting the new kernel.
> 
> I wouldn't call "quiesce a device" much more tricky. We have to do
> that for other devices as well today.

And since there is no standard way of doing it, we keep inventing
weird and wonderful ways of doing so -- cue the terrible GICv3 LPI
situation, and all the various hacks to keep existing IOMMU mappings
around across firmware/kernel handovers as well as kexec.

> 
> >   b) If there is more than one entity that is interested in the
> > information (e.g. firmware and kernel) then this requires some form of
> > arbitration in the guest because the hypervisor doesn't want to have to
> > track an arbitrary number of regions to update.
> 
> Why would FW care?

Exactly. It doesn't care. Not caring means it doesn't know about the
page the guest has allocated for stolen time, and starts using it for
its own purposes. Hello, memory corruption. Same thing goes if you
reboot into a non stolen time aware kernel.

> 
> >   c) Performance can suffer if the host kernel doesn't have a suitably
> > aligned/sized area to use. As you say - put_user() is more expensive.
> 
> Just define the interface to always require natural alignment when
> donating a memory location?
> 
> > The structure is updated on every return to the VM.
> 
> If you really do suffer from put_user(), there are alternatives. You
> could just map the page on the registration hcall and then leave it
> pinned until the vcpu gets destroyed again.

put_user() should be cheap enough. It is one of the things we tend to
optimise anyway. And yes, worse case, we pin the page.

> 
> > Of course x86 does prove the third approach can work, but I'm not sure
> > which is actually better. Avoid the kexec cancellation requirements was
> > the main driver of the current approach. Although many of the
> 
> I really don't understand the problem with kexec cancellation. Worst
> case, let guest FW set it up for you and propagate only the address
> down via ACPI/DT. That way you can mark the respective memory as
> reserved too.

We already went down that road with the LPI hack. I'm not going there
again if we can avoid it. And it turn out that we can. Just allocate
the stolen time page as a separate memblock, give it to KVM for that
purpose.

Your suggestion of letting the guest firmware set something up only
works if whatever you're booting after that understands it. If it
doesn't, you're screwed.

> But even with a Linux only mechanism, just take a look at
> arch/x86/kernel/kvmclock.c. All they do to remove the map is to hook
> into machine_crash_shutdown() and machine_shutdown().

I'm not going to take something that is Linux specific. It has to work
for all guests, at all times, whether they know about the hypervisor
service or not.

	M.

> 
> 
> Alex
> 
> > conversations about this were also tied up with Live Physical Time which
> > adds its own complications.
> > 
> > Steve
> > _______________________________________________
> > kvmarm mailing list
> > kvmarm@lists.cs.columbia.edu
> > https://lists.cs.columbia.edu/mailman/listinfo/kvmarm
> > 

-- 
Jazz is not dead, it just smells funny.

_______________________________________________
linux-arm-kernel mailing list
linux-arm-kernel@lists.infradead.org
http://lists.infradead.org/mailman/listinfo/linux-arm-kernel
